export const data = JSON.parse("{\"key\":\"v-0c5c465a\",\"path\":\"/CoderNotes/01_JavaSE%E9%98%B6%E6%AE%B5/D_JDK%E6%96%B0%E7%89%B9%E6%80%A7/01_JDK8%E6%96%B0%E7%89%B9%E6%80%A7/02_%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.html\",\"title\":\"函数式接口\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"函数式接口\",\"icon\":\"file\",\"order\":1,\"author\":\"十七\",\"date\":\"2023-06-15 周四\",\"category\":[\"JavaSE阶段\"],\"tag\":[\"Java基础\"],\"sticky\":true,\"index\":true,\"description\":\"函数式接口的由来 我们知道使用Lambda表达式的前提是需要有函数式接口，而Lambda表达式使用时不关心接口名， 抽象方法名。 只关心抽象方法的参数列表和返回值类型。 因此为了让我们使用Lambda表达式更加的方便，在JDK中提供了大量常用的函数式接口 Supplier接口 生产者接口，无参有返回值，使用时需要提供一个返回值类型 get() Cons...\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://me-turing.github.io/CoderNotes/CoderNotes/CoderNotes/01_JavaSE%E9%98%B6%E6%AE%B5/D_JDK%E6%96%B0%E7%89%B9%E6%80%A7/01_JDK8%E6%96%B0%E7%89%B9%E6%80%A7/02_%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.html\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"函数式接口\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"函数式接口的由来 我们知道使用Lambda表达式的前提是需要有函数式接口，而Lambda表达式使用时不关心接口名， 抽象方法名。 只关心抽象方法的参数列表和返回值类型。 因此为了让我们使用Lambda表达式更加的方便，在JDK中提供了大量常用的函数式接口 Supplier接口 生产者接口，无参有返回值，使用时需要提供一个返回值类型 get() Cons...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:updated_time\",\"content\":\"2023-06-16T06:43:34.000Z\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"十七\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"Java基础\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2023-06-14T16:00:00.000Z\"}],[\"meta\",{\"property\":\"article:modified_time\",\"content\":\"2023-06-16T06:43:34.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"函数式接口\\\",\\\"image\\\":[\\\"\\\"],\\\"datePublished\\\":\\\"2023-06-14T16:00:00.000Z\\\",\\\"dateModified\\\":\\\"2023-06-16T06:43:34.000Z\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"十七\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"函数式接口的由来\",\"slug\":\"函数式接口的由来\",\"link\":\"#函数式接口的由来\",\"children\":[]},{\"level\":2,\"title\":\"Supplier接口\",\"slug\":\"supplier接口\",\"link\":\"#supplier接口\",\"children\":[{\"level\":3,\"title\":\"get()\",\"slug\":\"get\",\"link\":\"#get\",\"children\":[]}]},{\"level\":2,\"title\":\"Consumer接口\",\"slug\":\"consumer接口\",\"link\":\"#consumer接口\",\"children\":[{\"level\":3,\"title\":\"accept方法\",\"slug\":\"accept方法\",\"link\":\"#accept方法\",\"children\":[]},{\"level\":3,\"title\":\"andThen方法\",\"slug\":\"andthen方法\",\"link\":\"#andthen方法\",\"children\":[]}]},{\"level\":2,\"title\":\"Function接口\",\"slug\":\"function接口\",\"link\":\"#function接口\",\"children\":[{\"level\":3,\"title\":\"apply方法\",\"slug\":\"apply方法\",\"link\":\"#apply方法\",\"children\":[]},{\"level\":3,\"title\":\"andThen方法\",\"slug\":\"andthen方法-1\",\"link\":\"#andthen方法-1\",\"children\":[]},{\"level\":3,\"title\":\"compose方法\",\"slug\":\"compose方法\",\"link\":\"#compose方法\",\"children\":[]},{\"level\":3,\"title\":\"identity方法\",\"slug\":\"identity方法\",\"link\":\"#identity方法\",\"children\":[]}]},{\"level\":2,\"title\":\"Predicate接口\",\"slug\":\"predicate接口\",\"link\":\"#predicate接口\",\"children\":[{\"level\":3,\"title\":\"test()\",\"slug\":\"test\",\"link\":\"#test\",\"children\":[]},{\"level\":3,\"title\":\"and()/or()/negate()\",\"slug\":\"and-or-negate\",\"link\":\"#and-or-negate\",\"children\":[]}]}],\"git\":{\"createdTime\":1686897814000,\"updatedTime\":1686897814000,\"contributors\":[{\"name\":\"Meturing\",\"email\":\"2339989978@qq.com\",\"commits\":1}]},\"readingTime\":{\"minutes\":3.58,\"words\":1075},\"filePathRelative\":\"CoderNotes/01_JavaSE阶段/D_JDK新特性/01_JDK8新特性/02_函数式接口/函数式接口.md\",\"localizedDate\":\"2023年6月15日\",\"autoDesc\":true,\"excerpt\":\"\"}")
