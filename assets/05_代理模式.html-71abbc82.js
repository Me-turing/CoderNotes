const e=JSON.parse('{"key":"v-412a8c30","path":"/doc/02_%E5%88%9D%E7%BA%A7%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/01_%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/06_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02_%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/05_%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html","title":"05_代理模式","lang":"zh-CN","frontmatter":{"title":"05_代理模式","icon":"file","order":1,"author":"十七","date":"2023-08-16 周三","category":["初级开发工程师"],"tag":["P5"],"sticky":true,"index":true,"description":"概览 介绍 在软件开发中,由于一些原因,客户端不想或不能直接访问一个对象,此时可以通过一个称为\\"代理\\"的第三者来实现间接访问.该方案对应的设计模式被称为代理模式. 代理模式(Proxy Design Pattern ) 原始定义是：让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许将请求提交给对象前后进行一些处理。 现实生活中的代理...","head":[["meta",{"property":"og:url","content":"https://me-turing.github.io/CoderNotes/CoderNotes/doc/02_%E5%88%9D%E7%BA%A7%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/01_%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/06_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02_%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/05_%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:title","content":"05_代理模式"}],["meta",{"property":"og:description","content":"概览 介绍 在软件开发中,由于一些原因,客户端不想或不能直接访问一个对象,此时可以通过一个称为\\"代理\\"的第三者来实现间接访问.该方案对应的设计模式被称为代理模式. 代理模式(Proxy Design Pattern ) 原始定义是：让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许将请求提交给对象前后进行一些处理。 现实生活中的代理..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-10T02:49:38.000Z"}],["meta",{"property":"article:author","content":"十七"}],["meta",{"property":"article:tag","content":"P5"}],["meta",{"property":"article:published_time","content":"2023-08-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-10T02:49:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"05_代理模式\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-16T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-10T02:49:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"十七\\"}]}"]]},"headers":[{"level":2,"title":"概览","slug":"概览","link":"#概览","children":[{"level":3,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]}]},{"level":2,"title":"静态代理","slug":"静态代理","link":"#静态代理","children":[]},{"level":2,"title":"JDK动态代理","slug":"jdk动态代理","link":"#jdk动态代理","children":[{"level":3,"title":"实现JDK动态代理","slug":"实现jdk动态代理","link":"#实现jdk动态代理","children":[]},{"level":3,"title":"类是如何动态生成的","slug":"类是如何动态生成的","link":"#类是如何动态生成的","children":[]},{"level":3,"title":"代理类的调用过程","slug":"代理类的调用过程","link":"#代理类的调用过程","children":[]}]},{"level":2,"title":"CGLIB动态代理","slug":"cglib动态代理","link":"#cglib动态代理","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"实现CGLIB动态代理","slug":"实现cglib动态代理","link":"#实现cglib动态代理","children":[]},{"level":3,"title":"cglib代理流程","slug":"cglib代理流程","link":"#cglib代理流程","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[{"level":3,"title":"三种代理模式实现方式的对比","slug":"三种代理模式实现方式的对比","link":"#三种代理模式实现方式的对比","children":[]}]}],"git":{"createdTime":1692157484000,"updatedTime":1696906178000,"contributors":[{"name":"SEVENTEEN","email":"2339989978@qq.com","commits":5}]},"readingTime":{"minutes":10.73,"words":3219},"filePathRelative":"doc/02_初级开发工程师/01_第一阶段/06_设计模式/02_二十三种设计模式/02_结构型模式/05_代理模式.md","localizedDate":"2023年8月16日","autoDesc":true,"excerpt":""}');export{e as data};
